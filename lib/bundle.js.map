{"version":3,"sources":["webpack:///webpack/bootstrap b5cb2803b2b29994eff0","webpack:///./lib/entry.js","webpack:///./lib/gameView.js","webpack:///./lib/mandelbrot.js","webpack:///./lib/colors.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACPD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB;AACxB;AACA;AACA,sCAAqC,mCAAmC;AACxE;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzFA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,WAAW;AAC5B;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,yBAAyB;AAC1C;AACA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,eAAe;AAC/D,sDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;;;;;;;AChKA;AACA;AACA,qBAAoB;AACpB;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;;;;AAIH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b5cb2803b2b29994eff0\n **/","var GameView = require('./gameView');\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  var canvas = document.getElementById(\"root\");\n  var context = canvas.getContext(\"2d\");\n  var view = new GameView(context);\n  view.start();\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/entry.js\n ** module id = 0\n ** module chunks = 0\n **/","var Mandelbrot  = require('./mandelbrot');\n\nvar GameView = function(context){\n  this.context = context;\n  this.mandelbrot = mandelbrot = new Mandelbrot(this.context.canvas.width,\n    this.context.canvas.height);\n  this.maxIterations = 1;\n}\n\nGameView.prototype.start = function(){\n  var that = this;\n  var defaultColor = -1; //greyscale\n  this.timeout = setInterval(function(){\n    if (that.maxIterations < 35){\n      that.draw(that.maxIterations, {color: defaultColor, smooth: false});\n      that.maxIterations++;\n    } else {\n      clearInterval(that.timeout);\n    }\n  }, 100);\n  this.addListeners();\n};\n\nGameView.prototype.addListeners = function () {\n  // this.addDrawListener();\n  this.addCanvasListener();\n  this.addIterationListeners();\n  this.addColorListener();\n  this.addSmoothingListener();\n};\n\nGameView.prototype.startDraw = function () {\n  var value = parseInt(document.getElementById(\"amountInput\").value);\n  var options = {};\n  options[\"color\"] = parseInt(document.getElementById(\"color\").value);\n  options[\"smooth\"] = document.getElementById(\"smooth\").checked;\n  clearInterval(this.timeout);\n  this.draw(value, options);\n};\n\nGameView.prototype.addColorListener = function () {\n  var that = this;\n  document.getElementById('color').addEventListener(\"change\", function(){\n    that.startDraw();\n  });\n};\n\nGameView.prototype.addSmoothingListener = function(){\n  var that = this;\n  document.getElementById('smooth').addEventListener('change', function(){\n    that.startDraw();\n  });\n};\n\n\n// GameView.prototype.addDrawListener = function () {\n//   // var that = this;\n//   document.getElementById(\"draw\").addEventListener(\"click\",this.startDraw.bind(this));\n// };\n\nGameView.prototype.addCanvasListener = function () {\n  var that = this;\n  document.getElementById(\"root\").addEventListener(\"click\", function(e){\n    var zoomLevel = (parseInt(document.getElementById('zoomInput').value) + 100)/100;\n    if (zoomLevel <= 1) return;\n    var x = e.offsetX;\n    var y = e.offsetY;\n    that.mandelbrot.zoom(x,y, that.context, zoomLevel);\n    that.startDraw();\n  });\n};\n\nGameView.prototype.addIterationListeners = function(){\n  var that = this;\n  document.getElementById(\"amountRange\").addEventListener(\"change\", function(e){\n    that.startDraw();\n  });\n  document.getElementById(\"amountInput\").addEventListener(\"change\", function(){\n    that.startDraw();\n  })\n};\n\nGameView.prototype.draw = function(maxIterations, options){\n  var data = this.mandelbrot.draw(maxIterations, this.context, options);\n  var canvas = this.context.canvas;\n  this.context.clearRect(0,0,this.context.canvas.width, this.context.canvas.height);\n  this.context.putImageData(data, 0,0);\n};\n\nmodule.exports = GameView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/gameView.js\n ** module id = 1\n ** module chunks = 0\n **/","var Colors = require('./colors');\n\nvar Mandelbrot = function(width, height, xMin, xMax, yMin, yMax){\n  this.setup(width, height, xMin, xMax, yMin, yMax)\n  this.zoomed = false;\n};\n\nMandelbrot.prototype.setup = function (width, height, xMin, xMax, yMin, yMax) {\n  xMin = xMin || -2.5;\n  xMax = xMax || 1;\n  yMin = yMin || -1;\n  yMax = yMax || 1;\n  var xScale = (xMax - xMin)/width;\n  var xOffset = xMin;\n  var yScale = (yMin - yMax)/height;\n  var yOffset = yMax;\n  this.xCoords = [];\n  this.yCoords = [];\n  for (var i = 0; i < width; i++) {\n    var x = (xScale * i) + xOffset;\n    this.xCoords.push(x);\n  }\n  for (var j = 0; j < height; j++) {\n    var y = yScale * j + yOffset;\n    this.yCoords.push(y);\n  }\n};\n\nMandelbrot.prototype.generate = function (maxIterations, option) {\n  var iterCount = [];\n  for (var i = 0; i < this.yCoords.length; i++) {\n    var row = [];\n    for (var j = 0; j < this.xCoords.length; j++){\n      var iter = this.iterCount(this.xCoords[j],this.yCoords[i], maxIterations, option);\n      row.push(iter);\n      this.min = Math.min(this.min, iter);\n    }\n    iterCount.push(row);\n  }\n  return iterCount;\n};\n\nMandelbrot.prototype.iterCount = function (x0, y0, maxIterations, smooth) {\n  //optimization: check if within main sections\n  if (maxIterations > 5){\n    var y2 = y0 * y0;\n    var q = (x0 - .25)*(x0 - .25) + y2;\n    if (q * (q + x0 - .25) < y2/4 || (x0 + 1) * (x0+1) + y2 < (1/16)){\n      return maxIterations;\n    }\n  }\n  //using a larger value on the upper bound gives better resolution of early details\n  //but completely wrecks lower iteration numbers\n\n  var UPPERBOUND = Math.pow(2,8);\n  var xTemp = x = y = 0;\n  var iteration = 0;\n  while (iteration < maxIterations && x*x + y*y < UPPERBOUND){\n    iteration += 1;\n    xTemp = x*x - y*y + x0;\n    yTemp = 2*x*y + y0;\n    if (xTemp === x && yTemp === y) break;\n    x = xTemp;\n    y = yTemp;\n  }\n\n  if (smooth && iteration < maxIterations){\n    var log = Math.log10(x*x + y*y) /2;\n    var nu = Math.log10(log / Math.log10(2)) / Math.log10(2);\n    iteration = iteration + 1 - nu;\n  }\n\n  return iteration;\n};\n\n\nMandelbrot.prototype.draw = function (maxIterations, context, options) {\n  this.max = maxIterations;\n  this.min = maxIterations;\n  if (options[\"smooth\"] === undefined){\n    options[\"smooth\"] = true;\n  }\n  if (options[\"color\"] === undefined){\n    options[\"color\"] = -1;\n  }\n  var iterations = this.generate(maxIterations, options[\"smooth\"]);\n  return this.colorize(iterations, context, options[\"color\"]);\n};\n\nMandelbrot.prototype.colorize = function(iterations, context, colorOption){\n  var imgData = context.createImageData(context.canvas.width, context.canvas.height);\n  var data = imgData.data;\n  //normalize colors\n  var coord = 0;\n  // iterate over the results and map the color to the appropriate pixel\n  for (var i = 0, rowLength = iterations.length; i < rowLength; i++) {\n    for (var j = 0, colLength = iterations[j].length; j < colLength; j++){\n      var colors = Colors.color(this.max, this.min, iterations[i][j], colorOption);\n      data[coord] = colors[0];\n      data[coord + 1] = colors[1];\n      data[coord + 2] = colors[2];\n      data[coord + 3] = colors[3];\n      coord += 4;\n    }\n  }\n  return imgData;\n}\n\nMandelbrot.prototype.rescale = function (zoom, clickLocation, absolute, originalCoords) {\n  if (zoom == 1) return originalCoords;\n  var location = clickLocation/absolute;\n  var reciprocal = 1/zoom;\n  var min, max;\n  var oMin = originalCoords[0];\n  var oMax = originalCoords[1];\n  var oDiff = oMax - oMin;\n  if (location < reciprocal/2){\n    min = oMin;\n    max = min + (oDiff * reciprocal)\n  } else if (location > (1 - location/2)){\n    min = oMax - oDiff * reciprocal;\n    max = oMax;\n  } else {\n    min = oMin + oDiff * (location - reciprocal/2);\n    max = oMin + oDiff * (location + reciprocal/2);\n  }\n  return [min, max];\n};\n\nMandelbrot.prototype.zoom = function (x,y, context,zoom) {\n  var canvas = context.canvas;\n  var width = canvas.width;\n  var height = canvas.height;\n  var originalXCoords = [-2.5,1];\n  var originalYCoords = [-1,1];\n  if (this.zoomed){\n    //reset bounding box to original coordinates\n    this.setup(width, height, originalXCoords[0], originalXCoords[1], originalYCoords[0], originalYCoords[1]);\n    canvas.className = \"canvas-default\";\n    this.zoomed = false;\n  } else {\n    canvas.className = \"canvas-zoomed\";\n    this.zoomed = true;\n    //calculate new viewing window based on x and y\n    //first get coordinates based on canvas\n    //attempt to maintain aspect ratio\n    // console.log(x)\n    // console.log(y);\n    var xCoords = this.rescale(zoom, x, width, originalXCoords);\n    var yCoords = this.rescale(zoom, height - y, height, originalYCoords);\n    // console.log(\"x: \" + xCoords);\n    // console.log(\"y: \" + yCoords);\n    this.setup(width, height, xCoords[0], xCoords[1], yCoords[0], yCoords[1]);\n  }\n};\n\n\n\nwindow.Mandelbrot = Mandelbrot;\n\nmodule.exports = Mandelbrot;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/mandelbrot.js\n ** module id = 2\n ** module chunks = 0\n **/","var Colors = {\n  greyscale: function (max, min, value) {\n    var alpha = 255; // opaque\n    if (max === min){\n      return [255,255,255, alpha];\n    } else {\n      var rgbVal = 255 * (1- (value)/(max - min));\n      return [rgbVal, rgbVal, rgbVal, alpha];\n    }\n  },\n\n  invertGrey: function(max, min, value){\n    var alpha = 255;\n    if (max === min){\n      return [0, 0, 0, alpha];\n    } else {\n      var rgbVal = 255 * (value)/(max - min);\n      return [rgbVal, rgbVal, rgbVal, alpha];\n    }\n  },\n\n  interpolate: function (arr1, arr2, percent) {\n    if (arr1.length != arr2.length){\n      return [];\n    }\n    return arr1.map(function(el, ind){\n      return el + percent * (arr2[ind] - el);\n    })\n\n  },\n\n\n\n  colors: [ // -1 greyscale, -2 inverted greyscale\n    [ [247,22,30], //0 - blue\n      [22,30,247],\n      [30,247,22] ],\n    [ [247,22,30], //1 - green\n      [30,247,22],\n      [22,30,247] ]\n\n  ],\n\n  color: function (max, min, value, colorSet) {\n    switch (colorSet) {\n      case -2:\n        return this.invertGrey(max, min, value);\n        break;\n      case -1:\n        return this.greyscale(max, min, value);\n        break;\n      default:\n        colors = this.colors[colorSet];\n        if (colors === undefined){\n          return this.greyscale(max, min, value);\n        }\n    }\n    alpha = 255;\n    if (max === min){\n      colors[0].push(alpha);\n      return colors[0];\n    }\n    var difference = (max - min);\n    //interpolate color based on which half of the color it falls under\n    if (value >= difference/2){\n      var arr1 = colors[0];\n      var arr2 = colors[1];\n    } else {\n      var arr1 = colors[1];\n      var arr2 = colors[2];\n    }\n    var results = this.interpolate(arr1, arr2, value/difference);\n    results.push(alpha);\n    return results;\n  }\n}\n\nmodule.exports = Colors;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/colors.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}