{"version":3,"sources":["webpack:///webpack/bootstrap ce935f8aab84d97c5480","webpack:///./lib/entry.js","webpack:///./lib/gameView.js","webpack:///./lib/mandelbrot.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACPD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAqC,kCAAkC;AACvE;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,WAAW;AAC5B;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,yBAAyB;AAC1C;AACA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAgD,eAAe;AAC/D,sDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB;AAClB;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ce935f8aab84d97c5480\n **/","var GameView = require('./gameView');\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  var canvas = document.getElementById(\"root\");\n  var context = canvas.getContext(\"2d\");\n  var view = new GameView(context);\n  view.start();\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/entry.js\n ** module id = 0\n ** module chunks = 0\n **/","var Mandelbrot  = require('./mandelbrot');\n\nvar GameView = function(context){\n  this.context = context;\n  this.mandelbrot = mandelbrot = new Mandelbrot(this.context.canvas.width,\n    this.context.canvas.height);\n  this.maxIterations = 1;\n}\n\nGameView.prototype.start = function(){\n  var that = this;\n  this.timeout = setInterval(function(){\n    if (that.maxIterations < 35){\n      that.draw(that.maxIterations, {color: \"greyscale\", smooth: false});\n      that.maxIterations++;\n    } else {\n      clearInterval(that.timeout);\n    }\n  }, 100);\n  this.addDrawListener();\n  this.addCanvasListener();\n};\n\nGameView.prototype.addDrawListener = function () {\n  var that = this;\n  document.getElementById(\"draw\").addEventListener(\"click\", function(){\n    var value = parseInt(document.getElementById(\"amountInput\").value);\n    var options = {};\n    options[\"color\"] = document.getElementById(\"color\").value;\n    options[\"smooth\"] = document.getElementById(\"smooth\").checked;\n    clearInterval(that.timeout);\n    that.draw(value, options);\n  })\n};\n\nGameView.prototype.addCanvasListener = function () {\n  document.getElementById(\"root\").addEventListener(\"click\", function(e){\n    var x = e.clientX;\n    var y = e.clientY;\n    console.log(x);\n    console.log(y);\n  });\n};\n\nGameView.prototype.draw = function(maxIterations, options){\n  var data = this.mandelbrot.draw(maxIterations, this.context, options);\n  var canvas = this.context.canvas;\n  this.context.clearRect(0,0,this.context.canvas.width, this.context.canvas.height);\n  this.context.putImageData(data, 0,0);\n};\n\nmodule.exports = GameView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/gameView.js\n ** module id = 1\n ** module chunks = 0\n **/","var Mandelbrot = function(width, height){\n  // scale each pixel from x in [-2.5, 1]\n  // y in [-1, 1]\n  var xScale = 3.5/width;\n  var xOffset = -2.5;\n  var yScale = -2/height;\n  var yOffset = 1;\n  this.xCoords = [];\n  this.yCoords = [];\n  for (var i = 0; i < width; i++) {\n    var x = (xScale * i) + xOffset;\n    this.xCoords.push(x);\n  }\n  for (var j = 0; j < height; j++) {\n    var y = yScale * j + yOffset;\n    this.yCoords.push(y);\n  }\n  // this.frequency = {};\n};\n\nMandelbrot.prototype.generate = function (maxIterations, options) {\n  if (options[\"smooth\"] === undefined){\n    options[\"smooth\"] = true;\n  }\n  var iterCount = [];\n  for (var i = 0; i < this.yCoords.length; i++) {\n    var row = [];\n    for (var j = 0; j < this.xCoords.length; j++){\n      var iter = this.iterCount(this.xCoords[j],this.yCoords[i], maxIterations, options[\"smooth\"])\n      row.push(iter);\n      this.min = Math.min(this.min, iter);\n    }\n    iterCount.push(row);\n  }\n  return iterCount;\n};\n\nMandelbrot.prototype.iterCount = function (x0, y0, maxIterations, smooth) {\n  //optimization: check if within main sections\n  if (maxIterations > 5){\n    var y2 = y0 * y0;\n    var q = (x0 - .25)*(x0 - .25) + y2;\n    if (q * (q + x0 - .25) < y2/4 || (x0 + 1) * (x0+1) + y2 < (1/16)){\n      return maxIterations;\n    }\n  }\n  //using a larger value on the upper bound gives better resolution of early details\n  //but completely wrecks lower iteration numbers\n  //\n  // if (maxIterations < 6){\n  //   var power = maxIterations + 1;\n  // } else {\n  //   power = 8;\n  // }\n  var UPPERBOUND = Math.pow(2,8);\n  var xTemp = x = y = 0;\n  var iteration = 0;\n  while (iteration < maxIterations && x*x + y*y < UPPERBOUND){\n    iteration += 1;\n    xTemp = x*x - y*y + x0;\n    yTemp = 2*x*y + y0;\n    if (xTemp === x && yTemp === y) break;\n    x = xTemp;\n    y = yTemp;\n  }\n\n  if (smooth && iteration < maxIterations){\n    var log = Math.log10(x*x + y*y) /2;\n    var nu = Math.log10(log / Math.log10(2)) / Math.log10(2);\n    iteration = iteration + 1 - nu;\n  }\n\n\n  // if (!this.frequency[iteration]){\n  //   this.frequency[iteration] = 1;\n  // } else {\n  //   this.frequency[iteration] += 1;\n  // }\n  return iteration;\n};\n\n\nMandelbrot.prototype.draw = function (maxIterations, context, options) {\n  this.max = maxIterations;\n  this.min = maxIterations;\n  var iterations = this.generate(maxIterations, options);\n  return this.colorize(iterations, context, options);\n};\n\nMandelbrot.prototype.colorize = function(iterations, context, options){\n  if (options[\"color\"] === \"color\"){\n    var colorFunc = this.colors.bind(this);\n  } else {\n    colorFunc = this.greyscale.bind(this);\n  }\n  // var keys = Object.keys(this.frequency).map(function(el){\n  //   return parseInt(el);\n  // });\n  // var max = Math.max.apply(null, keys);\n  // var min = Math.min.apply(null, keys);\n\n  var imgData = context.createImageData(context.canvas.width, context.canvas.height);\n  var data = imgData.data;\n  //normalize colors\n  var coord = 0;\n  // iterate over the results and map the color to the appropriate pixel\n  for (var i = 0, rowLength = iterations.length; i < rowLength; i++) {\n    for (var j = 0, colLength = iterations[j].length; j < colLength; j++){\n      // var coord = 4 * (i * rowLength + j);\n      // debugger;\n      var colors = colorFunc(this.max, this.min, iterations[i][j]);\n      data[coord] = colors[0];\n      data[coord + 1] = colors[1];\n      data[coord + 2] = colors[2];\n      data[coord + 3] = colors[3];\n      coord += 4;\n    }\n  }\n  // this.frequency = {};\n  return imgData;\n}\n\nMandelbrot.prototype.greyscale = function (max, min, value) {\n  var alpha = 255; // opaque\n  if (max === min){\n    return [255,255,255, alpha];\n  } else {\n    var rgbVal = 255 * (1- (value)/(max - min));\n    return [rgbVal, rgbVal, rgbVal, alpha];\n  }\n  // var scale = 255/(max - min);\n  // var offset = -min * scale;\n  // var rgbVal = (scale * value) + offset;\n};\n\nMandelbrot.prototype.interpolate = function (arr1, arr2, percent) {\n  if (arr1.length != arr2.length){\n    return [];\n  }\n  return arr1.map(function(el, ind){\n    return el + percent * (arr2[ind] - el);\n  })\n\n};\n\nMandelbrot.prototype.colors = function (max, min, value) {\n  alpha = 255;\n  var colors = [\n    [247,22,30],\n    [22,30,247],\n    [30,247,22] ];\n  if (max === min){\n    colors[0].push(alpha);\n    return colors[0];\n  }\n  var difference = (max - min);\n  //interpolate color based on which half of the color it falls under\n  if (value >= difference/2){\n    var arr1 = colors[0];\n    var arr2 = colors[1];\n  } else {\n    var arr1 = colors[1];\n    var arr2 = colors[2];\n  }\n  // debugger;\n  var results = this.interpolate(arr1, arr2, value/difference);\n  results.push(alpha);\n  return results;\n};\n\n\n\n\n\nwindow.Mandelbrot = Mandelbrot;\n\nmodule.exports = Mandelbrot;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/mandelbrot.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}